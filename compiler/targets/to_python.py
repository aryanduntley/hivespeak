"""HiveTalk → Python transpiler.

Converts HiveTalk AST to Python source code.
Pure functional — no global state, no classes.
"""


def compile_to_python(ast_nodes):
    """Compile a list of AST nodes to Python source string."""
    ctx = {"indent": 0, "defs": set()}
    lines = [
        "# Generated by HiveTalk compiler v0.1.0",
        "# Target: Python",
        "",
        "import hashlib, json, time, sys",
        "",
        "# HiveTalk runtime helpers",
        "_packets = {}",
        "",
        "def _ht_cell(state):",
        "    cid = hashlib.sha256(json.dumps(str(state)).encode()).hexdigest()[:12]",
        "    return {'__type__': 'cell', 'id': cid, 'state': dict(state), 'inbox': []}",
        "",
        "def _ht_emit(cell, target, content):",
        "    if isinstance(target, dict) and target.get('__type__') == 'cell':",
        "        target['inbox'].append({'from': cell.get('id'), 'content': content})",
        "    return content",
        "",
        "def _ht_recv(cell):",
        "    return cell['inbox'].pop(0) if cell.get('inbox') else None",
        "",
        "def _ht_merge(cells, keys=None):",
        "    merged = {}",
        "    for c in cells:",
        "        for k, v in c.get('state', {}).items():",
        "            if keys is None or k in keys:",
        "                merged.setdefault(k, []).append(v)",
        "    return {'__type__': 'collective', 'shared': merged, 'cells': cells}",
        "",
        "def _ht_compress(coll):",
        "    shared = coll.get('shared', {})",
        "    compressed = {}",
        "    for k, values in shared.items():",
        "        if values:",
        "            counts = {}",
        "            for v in values:",
        "                counts[str(v)] = counts.get(str(v), 0) + 1",
        "            winner = max(counts, key=counts.get)",
        "            compressed[k] = next(v for v in values if str(v) == winner)",
        "    h = hashlib.sha256(json.dumps(str(compressed)).encode()).hexdigest()[:12]",
        "    pkt = {'__type__': 'packet', 'hash': h, 'data': compressed}",
        "    _packets[h] = pkt",
        "    return {'ok': pkt}",
        "",
        "def _ht_packet(data):",
        "    h = hashlib.sha256(json.dumps(str(data)).encode()).hexdigest()[:12]",
        "    pkt = {'__type__': 'packet', 'hash': h, 'data': data}",
        "    _packets[h] = pkt",
        "    return pkt",
        "",
        "def _ht_ref(h): return _packets.get(h)",
        "",
        "# Generated code",
        "",
    ]
    for node in ast_nodes:
        lines.append(_compile_node(node, ctx))
    return "\n".join(lines)


# ─── Node compilation ─────────────────────────────────────────────────────

# Dispatch table: node_type -> compiler function
_COMPILERS = {}


def _compile_node(node, ctx):
    """Compile an AST node to a Python expression or statement string."""
    nt = node[0]
    compiler = _COMPILERS.get(nt, _compile_default)
    return compiler(node, ctx)


def _compile_default(node, ctx):
    return repr(node)


def _c_int(node, ctx):    return str(node[1])
def _c_float(node, ctx):  return str(node[1])
def _c_str(node, ctx):    return repr(node[1])
def _c_bool(node, ctx):   return "True" if node[1] else "False"
def _c_null(node, ctx):   return "None"
def _c_sym(node, ctx):    return _mangle(node[1])
def _c_kw(node, ctx):     return repr(node[1])
def _c_hash(node, ctx):   return f"_ht_ref({repr(node[1])})"


def _c_list(node, ctx):
    elements = [_compile_node(el, ctx) for el in node[1]]
    return "[" + ", ".join(elements) + "]"


def _c_map(node, ctx):
    pairs = node[1]
    items = []
    i = 0
    while i < len(pairs) - 1:
        k = _compile_node(pairs[i], ctx)
        v = _compile_node(pairs[i + 1], ctx)
        items.append(f"{k}: {v}")
        i += 2
    return "{" + ", ".join(items) + "}"


def _c_sexpr(node, ctx):
    elements = node[1]
    if not elements:
        return "None"
    head = elements[0]
    args = elements[1:]

    if head[0] == "SYM":
        name = head[1]
        compiler = _SEXPR_COMPILERS.get(name)
        if compiler:
            return compiler(args, ctx)
        # Operator mapping
        if name in _OP_MAP:
            return _compile_op(name, args, ctx)

    # Generic function call
    fn = _compile_node(head, ctx)
    compiled_args = [_compile_node(a, ctx) for a in args]
    return f"{fn}({', '.join(compiled_args)})"


def _c_quote(node, ctx):
    return repr(_ast_to_pydata(node[1]))


# ─── Register compilers ───────────────────────────────────────────────────

_COMPILERS.update({
    "INT": _c_int, "FLOAT": _c_float, "STR": _c_str, "BOOL": _c_bool,
    "NULL": _c_null, "SYM": _c_sym, "KW": _c_kw, "HASH": _c_hash,
    "LIST": _c_list, "MAP": _c_map, "SEXPR": _c_sexpr, "QUOTE": _c_quote,
})


# ─── Special form compilers ───────────────────────────────────────────────

def _sc_def(args, ctx):
    if args[0][0] == "SEXPR":
        # Function shorthand: (def (name params...) body...)
        parts = args[0][1]
        name = _mangle(parts[0][1])
        params = ", ".join(_mangle(p[1]) for p in parts[1:])
        body_lines = [_compile_node(a, ctx) for a in args[1:]]
        body = "; ".join(body_lines[:-1] + [f"return {body_lines[-1]}"])  if body_lines else "return None"
        return f"def {name}({params}): {body}"
    name = _mangle(args[0][1])
    val = _compile_node(args[1], ctx)
    return f"{name} = {val}"


def _sc_let(args, ctx):
    bindings = args[0][1]
    body = args[1:]
    parts = []
    i = 0
    while i < len(bindings) - 1:
        name = _mangle(bindings[i][1])
        val = _compile_node(bindings[i + 1], ctx)
        parts.append(f"{name} = {val}")
        i += 2
    body_compiled = [_compile_node(b, ctx) for b in body]
    # Use a lambda wrapper for scoping
    all_parts = parts + body_compiled
    return "(lambda: (" + ", ".join(all_parts) + ")[-1])()"


def _sc_fn(args, ctx):
    params = ", ".join(_mangle(p[1]) for p in args[0][1])
    if len(args) == 2:
        body = _compile_node(args[1], ctx)
        return f"lambda {params}: {body}"
    body_lines = [_compile_node(a, ctx) for a in args[1:]]
    last = body_lines[-1]
    setup = "; ".join(body_lines[:-1])
    if setup:
        return f"(lambda {params}: (({setup}), {last})[-1])"
    return f"lambda {params}: {last}"


def _sc_if(args, ctx):
    cond = _compile_node(args[0], ctx)
    then = _compile_node(args[1], ctx)
    els = _compile_node(args[2], ctx) if len(args) > 2 else "None"
    return f"({then} if {cond} else {els})"


def _sc_do(args, ctx):
    parts = [_compile_node(a, ctx) for a in args]
    if len(parts) == 1:
        return parts[0]
    return "[" + ", ".join(parts) + "][-1]"


def _sc_loop(args, ctx):
    # Compile loop/recur to a while True with break
    bindings = args[0][1]
    body = args[1:]
    names = []
    vals = []
    i = 0
    while i < len(bindings) - 1:
        names.append(_mangle(bindings[i][1]))
        vals.append(_compile_node(bindings[i + 1], ctx))
        i += 2
    init = "; ".join(f"{n} = {v}" for n, v in zip(names, vals))
    body_compiled = [_compile_node(b, ctx) for b in body]
    body_str = body_compiled[-1] if body_compiled else "None"
    return f"(lambda: (exec('{init}'), {body_str}))()"


def _sc_match(args, ctx):
    val = _compile_node(args[0], ctx)
    cases = []
    i = 1
    while i < len(args) - 1:
        pat = args[i]
        res = _compile_node(args[i + 1], ctx)
        if pat[0] == "SYM" and pat[1] == "_":
            cases.append(res)
            break
        pat_val = _compile_node(pat, ctx)
        cases.append(f"{res} if _m == {pat_val} else")
        i += 2
    if not cases:
        return "None"
    inner = " ".join(cases)
    if not inner.rstrip().endswith("else"):
        return f"(lambda _m: {inner})({val})"
    return f"(lambda _m: {inner} None)({val})"


def _sc_pipe(args, ctx):
    val = _compile_node(args[0], ctx)
    for step in args[1:]:
        if step[0] == "SEXPR":
            fn = _compile_node(step[1][0], ctx)
            step_args = [_compile_node(a, ctx) for a in step[1][1:]]
            step_args.append(val)
            val = f"{fn}({', '.join(step_args)})"
        elif step[0] == "SYM":
            fn = _compile_node(step, ctx)
            val = f"{fn}({val})"
        else:
            fn = _compile_node(step, ctx)
            val = f"{fn}({val})"
    return val


def _sc_print(args, ctx):
    compiled = [_compile_node(a, ctx) for a in args]
    return f"print({', '.join(compiled)})"


def _sc_cell(args, ctx):
    state = _compile_node(args[0], ctx)
    return f"_ht_cell({state})"


def _sc_emit(args, ctx):
    if len(args) >= 3:
        cell = _compile_node(args[0], ctx)
        target = _compile_node(args[1], ctx)
        content = _compile_node(args[2], ctx)
        return f"_ht_emit({cell}, {target}, {content})"
    return f"_ht_emit({', '.join(_compile_node(a, ctx) for a in args)})"


def _sc_merge(args, ctx):
    cells = _compile_node(args[0], ctx)
    if len(args) > 2:
        keys = _compile_node(args[2], ctx)
        return f"_ht_merge({cells}, {keys})"
    return f"_ht_merge({cells})"


def _sc_compress(args, ctx):
    return f"_ht_compress({_compile_node(args[0], ctx)})"


def _sc_packet(args, ctx):
    return f"_ht_packet({_compile_node(args[0], ctx)})"


def _sc_mod(args, ctx):
    name = _mangle(args[0][1])
    body_lines = [_compile_node(a, ctx) for a in args[1:]]
    # Compile module as a dict
    return f"{name} = {{}}\n" + "\n".join(body_lines)


def _sc_use(args, ctx):
    mod = _mangle(args[0][1])
    if len(args) == 1:
        return f"globals().update({mod})"
    names = [_mangle(a[1]) for a in args[1:]]
    return "; ".join(f"{n} = {mod}['{n}']" for n in names)


_SEXPR_COMPILERS = {
    "def": _sc_def, "let": _sc_let, "fn": _sc_fn, "if": _sc_if,
    "do": _sc_do, "loop": _sc_loop, "match": _sc_match, "|>": _sc_pipe,
    "print": _sc_print, "cell": _sc_cell, "emit": _sc_emit,
    "merge": _sc_merge, "compress": _sc_compress, "packet": _sc_packet,
    "mod": _sc_mod, "use": _sc_use,
}


# ─── Operator mapping ─────────────────────────────────────────────────────

_OP_MAP = {
    "+": "+", "-": "-", "*": "*", "/": "/", "%": "%",
    "=": "==", "!=": "!=", "<": "<", ">": ">", "<=": "<=", ">=": ">=",
    "and": "and", "or": "or", "not": "not",
}

# Built-in function name mapping
_BUILTIN_MAP = {
    "len": "len", "hd": "lambda l: l[0]", "tl": "lambda l: l[1:]",
    "nth": "lambda l, i: l[i]", "push": "lambda l, v: l + [v]",
    "map": "lambda f, l: list(map(f, l))",
    "flt": "lambda f, l: list(filter(f, l))",
    "red": "lambda f, i, l: __import__('functools').reduce(f, l, i)",
    "srt": "sorted", "rev": "lambda l: list(reversed(l))",
    "cat": "lambda *a: (a[0] + a[1]) if len(a) == 2 and isinstance(a[0], (list, str)) else ''.join(str(x) for x in a)",
    "slc": "lambda a, s, e=None: a[s:e]",
    "spl": "lambda a, s: a.split(s)",
    "upr": "lambda a: a.upper()", "lwr": "lambda a: a.lower()",
    "get": "lambda m, k: m.get(k)", "put": "lambda m, k, v: {**m, k: v}",
    "del": "lambda m, k: {a: b for a, b in m.items() if a != k}",
    "keys": "lambda m: list(m.keys())", "vals": "lambda m: list(m.values())",
    "has": "lambda m, k: k in m", "mrg": "lambda a, b: {**a, **b}",
    "type": "lambda v: type(v).__name__",
    "hash": "lambda v: __import__('hashlib').sha256(str(v).encode()).hexdigest()[:12]",
}


def _compile_op(name, args, ctx):
    py_op = _OP_MAP[name]
    compiled = [_compile_node(a, ctx) for a in args]
    if name == "not":
        return f"(not {compiled[0]})"
    if len(compiled) == 1:
        return f"({py_op}{compiled[0]})" if name == "-" else compiled[0]
    return f"({f' {py_op} '.join(compiled)})"


# ─── Helpers ───────────────────────────────────────────────────────────────

def _mangle(name):
    """Convert HiveTalk identifier to valid Python identifier."""
    replacements = {"-": "_", "?": "_q", "!": "_b", "~": "_t", "+": "_p", "|>": "_pipe"}
    result = name
    for old, new in replacements.items():
        result = result.replace(old, new)
    if result in ("and", "or", "not", "if", "def", "del", "from", "import",
                  "in", "is", "as", "with", "try", "except", "class", "return",
                  "while", "for", "break", "continue", "pass", "raise", "yield",
                  "lambda", "global", "nonlocal", "assert", "else", "elif"):
        result = f"ht_{result}"
    return result


def _ast_to_pydata(node):
    """Convert AST to Python data for quoted forms."""
    nt = node[0]
    if nt in ("INT", "FLOAT", "STR", "BOOL"):
        return node[1]
    if nt == "NULL":
        return None
    if nt == "SYM":
        return ("SYM", node[1])
    if nt == "KW":
        return node[1]
    if nt == "LIST":
        return [_ast_to_pydata(el) for el in node[1]]
    if nt == "MAP":
        result = {}
        i = 0
        els = node[1]
        while i < len(els) - 1:
            k = _ast_to_pydata(els[i])
            v = _ast_to_pydata(els[i + 1])
            result[k] = v
            i += 2
        return result
    if nt == "SEXPR":
        return [_ast_to_pydata(el) for el in node[1]]
    return str(node)
