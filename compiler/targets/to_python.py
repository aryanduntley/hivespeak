"""HiveSpeak → Python transpiler.

Converts HiveSpeak AST to Python source code.
Pure functional — no global state, no classes.
"""

import functools

_loop_counter = 0

def _next_loop_name():
    global _loop_counter
    _loop_counter += 1
    return f"_loop_{_loop_counter}"


def compile_to_python(ast_nodes):
    """Compile a list of AST nodes to Python source string."""
    global _loop_counter
    _loop_counter = 0
    ctx = {"indent": 0, "defs": set()}
    lines = [_PREAMBLE]
    for node in ast_nodes:
        lines.append(_compile_node(node, ctx))
    return "\n".join(lines)


_PREAMBLE = """\
# Generated by HiveSpeak compiler v0.2.0
# Target: Python

import hashlib, json, time, sys, functools

# ─── HiveSpeak runtime ────────────────────────────────────────────────────

_packets = {}

def _ht_cell(state):
    cid = hashlib.sha256(json.dumps(str(state)).encode()).hexdigest()[:12]
    return {'__type__': 'cell', 'id': cid, 'state': dict(state), 'inbox': []}

def _ht_emit(cell, target, content):
    if isinstance(target, dict) and target.get('__type__') == 'cell':
        target['inbox'].append({'from': cell.get('id'), 'content': content})
    return content

def _ht_recv(cell):
    return cell['inbox'].pop(0) if cell.get('inbox') else None

def _ht_merge(cells, keys=None):
    merged = {}
    for c in cells:
        for k, v in c.get('state', {}).items():
            if keys is None or k in keys:
                merged.setdefault(k, []).append(v)
    return {'__type__': 'collective', 'shared': merged, 'cells': cells}

def _ht_compress(coll):
    shared = coll.get('shared', {})
    compressed = {}
    for k, values in shared.items():
        if values:
            counts = {}
            for v in values:
                counts[str(v)] = counts.get(str(v), 0) + 1
            winner = max(counts, key=counts.get)
            compressed[k] = next(v for v in values if str(v) == winner)
    h = hashlib.sha256(json.dumps(str(compressed)).encode()).hexdigest()[:12]
    pkt = {'__type__': 'packet', 'hash': h, 'data': compressed}
    _packets[h] = pkt
    return {'ok': pkt}

def _ht_packet(data):
    h = hashlib.sha256(json.dumps(str(data)).encode()).hexdigest()[:12]
    pkt = {'__type__': 'packet', 'hash': h, 'data': data}
    _packets[h] = pkt
    return pkt

def _ht_ref(h): return _packets.get(h)

def _ht_intent(intent_type, content):
    return {'__type__': 'intent', 'intent': intent_type, 'content': content}

def _ht_set_state(cell, k, v):
    cell['state'][k] = v
    return cell['state']

# ─── Standard library ─────────────────────────────────────────────────────

def _ht_format_val(v):
    if v is None: return 'N'
    if v is True: return 'T'
    if v is False: return 'F'
    if isinstance(v, str): return v
    if isinstance(v, (int, float)): return str(v)
    if isinstance(v, list): return '[' + ' '.join(_ht_format_val(x) for x in v) + ']'
    if isinstance(v, dict):
        if v.get('__type__'):
            return '<' + v['__type__'] + ' ' + v.get('id', v.get('hash', '')) + '>'
        return '{' + ' '.join(':' + str(k) + ' ' + _ht_format_val(val) for k, val in v.items()) + '}'
    return str(v)

def _ht_print(*args):
    print(*[_ht_format_val(a) for a in args])

hd = lambda a: a[0] if a else None
tl = lambda a: a[1:] if a else []
nth = lambda a, i: a[i] if 0 <= i < len(a) else None
push = lambda a, v: a + [v]
srt = lambda a, key=None: sorted(a, key=key) if key else sorted(a)
rev = lambda a: list(reversed(a))
flat = lambda a: [x for sub in a for x in (sub if isinstance(sub, list) else [sub])]
uniq = lambda a: list(dict.fromkeys(a))
cat = lambda *a: ''.join(str(x) for x in a) if a and isinstance(a[0], str) else (list(a[0]) + list(a[1]) if len(a) == 2 and isinstance(a[0], list) else a[0])
slc = lambda a, s, e=None: a[s:e]
idx = lambda a, b: a.index(b) if b in a else -1
spl = lambda a, s: a.split(s)
upr = lambda a: a.upper()
lwr = lambda a: a.lower()
fmt = lambda t, *a: functools.reduce(lambda s, v: s.replace('{}', _ht_format_val(v), 1), a, t)
get = lambda m, k: m.get(k)
put = lambda m, k, v: {**m, k: v}
ht_del = lambda m, k: {a: b for a, b in m.items() if a != k}
keys = lambda m: [(':' + k if isinstance(k, str) else k) for k in m.keys() if k != '__type__']
vals = lambda m: list(v for k, v in m.items() if k != '__type__')
has = lambda m, k: k in m
mrg = lambda a, b: {**a, **b}
ht_map = lambda f, lst: list(map(f, lst))
flt = lambda f, lst: list(filter(f, lst))
red = lambda f, init, lst: functools.reduce(f, lst, init)
ht_any = lambda f, lst: any(f(x) for x in lst)
ht_all = lambda f, lst: all(f(x) for x in lst)
ht_range = lambda *a: list(range(*a))
ht_zip = lambda *lists: [list(x) for x in zip(*lists)]
ht_len = len
ht_type = lambda v: type(v).__name__
ht_hash = lambda v: hashlib.sha256(str(v).encode()).hexdigest()[:12]
ht_str = lambda v: _ht_format_val(v)
ht_int = int
ht_float = float
set_state = _ht_set_state
get_state = lambda c: c.get('state') if isinstance(c, dict) else None
assert_b = lambda c: _ht_intent('assert', c)
ask_q = lambda c: _ht_intent('ask', c)
request_b = lambda c: _ht_intent('request', c)
suggest_t = lambda c: _ht_intent('suggest', c)
accept_p = lambda c: _ht_intent('accept', c)
reject_ = lambda c: _ht_intent('reject', c)

# Operator functions (for passing as values, e.g. (red add 0 nums))
ht_add = lambda *a: functools.reduce(lambda x, y: x + y, a) if len(a) > 1 else a[0]
ht_sub = lambda *a: functools.reduce(lambda x, y: x - y, a) if len(a) > 1 else -a[0]
_s = lambda *a: functools.reduce(lambda x, y: x * y, a) if len(a) > 1 else a[0]
_d = lambda a, b: a / b if b != 0 else float('inf')
_eq = lambda a, b: a == b
_neq = lambda a, b: a != b
_lt = lambda a, b: a < b
ht_gt = lambda a, b: a > b
_lte = lambda a, b: a <= b
_gte = lambda a, b: a >= b

# Recur sentinel for loop/recur
class _Recur:
    def __init__(self, vals): self.vals = vals

# ─── Generated code ───────────────────────────────────────────────────────
"""


# ─── Node compilation ─────────────────────────────────────────────────────

_COMPILERS = {}


def _compile_node(node, ctx):
    """Compile an AST node to a Python expression or statement string."""
    nt = node[0]
    compiler = _COMPILERS.get(nt, _compile_default)
    return compiler(node, ctx)


def _compile_default(node, ctx):
    return repr(node)


def _c_int(node, ctx):    return str(node[1])
def _c_float(node, ctx):  return str(node[1])
def _c_str(node, ctx):    return repr(node[1])
def _c_bool(node, ctx):   return "True" if node[1] else "False"
def _c_null(node, ctx):   return "None"
def _c_sym(node, ctx):    return _mangle(node[1])
def _c_kw(node, ctx):     return repr(node[1])
def _c_hash(node, ctx):   return f"_ht_ref({repr(node[1])})"


def _c_list(node, ctx):
    elements = [_compile_node(el, ctx) for el in node[1]]
    return "[" + ", ".join(elements) + "]"


def _c_map(node, ctx):
    pairs = node[1]
    items = []
    i = 0
    while i < len(pairs) - 1:
        k = _compile_node(pairs[i], ctx)
        v = _compile_node(pairs[i + 1], ctx)
        items.append(f"{k}: {v}")
        i += 2
    return "{" + ", ".join(items) + "}"


def _c_sexpr(node, ctx):
    elements = node[1]
    if not elements:
        return "None"
    head = elements[0]
    args = elements[1:]

    if head[0] == "SYM":
        name = head[1]
        compiler = _SEXPR_COMPILERS.get(name)
        if compiler:
            return compiler(args, ctx)
        if name in _OP_MAP:
            return _compile_op(name, args, ctx)

    # Generic function call
    fn = _compile_node(head, ctx)
    compiled_args = [_compile_node(a, ctx) for a in args]
    return f"{fn}({', '.join(compiled_args)})"


def _c_quote(node, ctx):
    return repr(_ast_to_pydata(node[1]))


_COMPILERS.update({
    "INT": _c_int, "FLOAT": _c_float, "STR": _c_str, "BOOL": _c_bool,
    "NULL": _c_null, "SYM": _c_sym, "KW": _c_kw, "HASH": _c_hash,
    "LIST": _c_list, "MAP": _c_map, "SEXPR": _c_sexpr, "QUOTE": _c_quote,
})


# ─── Special form compilers ───────────────────────────────────────────────

def _sc_def(args, ctx):
    if args[0][0] == "SEXPR":
        # Function shorthand: (def (name params...) body...)
        parts = args[0][1]
        name = _mangle(parts[0][1])
        params = ", ".join(_mangle(p[1]) for p in parts[1:])
        body_lines = [_compile_node(a, ctx) for a in args[1:]]
        # Check if any body line is multi-line (e.g. loop generates helper functions)
        last = body_lines[-1]
        if len(body_lines) == 1 and "\n" not in last:
            return f"def {name}({params}): return {last}"
        # Multi-line body: indent everything inside the function
        indented = []
        for i, line in enumerate(body_lines):
            is_last = (i == len(body_lines) - 1)
            for j, sub in enumerate(line.split("\n")):
                if is_last and j == line.count("\n"):
                    # Last line of last expression — return it
                    indented.append(f"    return {sub}")
                else:
                    indented.append(f"    {sub}")
        return f"def {name}({params}):\n" + "\n".join(indented)
    name = _mangle(args[0][1])
    val = _compile_node(args[1], ctx)
    return f"{name} = {val}"


def _sc_let(args, ctx):
    """Compile let to a function call with bindings as sequential assignments."""
    bindings = args[0][1]
    body = args[1:]
    # Build as nested lambdas: (lambda a: (lambda b: body)(b_val))(a_val)
    names = []
    vals = []
    i = 0
    while i < len(bindings) - 1:
        names.append(_mangle(bindings[i][1]))
        vals.append(_compile_node(bindings[i + 1], ctx))
        i += 2
    body_compiled = [_compile_node(b, ctx) for b in body]
    result = body_compiled[-1] if body_compiled else "None"
    # Wrap from inside out
    expr = result
    for name, val in reversed(list(zip(names, vals))):
        expr = f"(lambda {name}: {expr})({val})"
    return expr


def _sc_fn(args, ctx):
    params = ", ".join(_mangle(p[1]) for p in args[0][1])
    if len(args) == 2:
        body = _compile_node(args[1], ctx)
        return f"(lambda {params}: {body})"
    body_lines = [_compile_node(a, ctx) for a in args[1:]]
    last = body_lines[-1]
    setup = "; ".join(body_lines[:-1])
    if setup:
        return f"(lambda {params}: (({setup}), {last})[-1])"
    return f"(lambda {params}: {last})"


def _sc_if(args, ctx):
    cond = _compile_node(args[0], ctx)
    then = _compile_node(args[1], ctx)
    els = _compile_node(args[2], ctx) if len(args) > 2 else "None"
    return f"({then} if {cond} else {els})"


def _sc_do(args, ctx):
    parts = [_compile_node(a, ctx) for a in args]
    if len(parts) == 1:
        return parts[0]
    return "[" + ", ".join(parts) + "][-1]"


def _sc_loop(args, ctx):
    """Compile loop/recur — emits a helper function + call."""
    bindings = args[0][1]
    body = args[1:]
    names = []
    vals = []
    i = 0
    while i < len(bindings) - 1:
        names.append(_mangle(bindings[i][1]))
        vals.append(_compile_node(bindings[i + 1], ctx))
        i += 2

    fn_name = _next_loop_name()
    name_list = ", ".join(names)
    init_args = ", ".join(vals)
    body_compiled = [_compile_node(b, ctx) for b in body]
    body_str = body_compiled[-1] if body_compiled else "None"
    unpack = f"{names[0]}, = _r.vals" if len(names) == 1 else f"{name_list} = _r.vals"

    # Emit a standalone function definition + call
    lines = [
        f"def {fn_name}({name_list}):",
        f"    recur = lambda {name_list}: _Recur([{name_list}])",
        f"    while True:",
        f"        _r = {body_str}",
        f"        if isinstance(_r, _Recur):",
        f"            {unpack}",
        f"        else:",
        f"            return _r",
    ]
    return "\n".join(lines) + f"\n{fn_name}({init_args})"


def _sc_match(args, ctx):
    val = _compile_node(args[0], ctx)
    cases = []
    i = 1
    while i < len(args) - 1:
        pat = args[i]
        res = _compile_node(args[i + 1], ctx)
        if pat[0] == "SYM" and pat[1] == "_":
            cases.append(res)
            break
        pat_val = _compile_node(pat, ctx)
        cases.append(f"{res} if _m == {pat_val} else")
        i += 2
    if not cases:
        return "None"
    inner = " ".join(cases)
    if not inner.rstrip().endswith("else"):
        return f"(lambda _m: {inner})({val})"
    return f"(lambda _m: {inner} None)({val})"


def _sc_pipe(args, ctx):
    val = _compile_node(args[0], ctx)
    for step in args[1:]:
        if step[0] == "SEXPR":
            fn = _compile_node(step[1][0], ctx)
            step_args = [_compile_node(a, ctx) for a in step[1][1:]]
            step_args.append(val)
            val = f"{fn}({', '.join(step_args)})"
        elif step[0] == "SYM":
            fn = _compile_node(step, ctx)
            val = f"{fn}({val})"
        else:
            fn = _compile_node(step, ctx)
            val = f"{fn}({val})"
    return val


def _sc_print(args, ctx):
    compiled = [_compile_node(a, ctx) for a in args]
    return f"_ht_print({', '.join(compiled)})"


def _sc_cell(args, ctx):
    state = _compile_node(args[0], ctx)
    return f"_ht_cell({state})"


def _sc_emit(args, ctx):
    if len(args) >= 3:
        cell = _compile_node(args[0], ctx)
        target = _compile_node(args[1], ctx)
        content = _compile_node(args[2], ctx)
        return f"_ht_emit({cell}, {target}, {content})"
    return f"_ht_emit({', '.join(_compile_node(a, ctx) for a in args)})"


def _sc_recv(args, ctx):
    return f"_ht_recv({_compile_node(args[0], ctx)})"


def _sc_merge(args, ctx):
    cells = _compile_node(args[0], ctx)
    if len(args) > 2:
        keys = _compile_node(args[2], ctx)
        return f"_ht_merge({cells}, {keys})"
    return f"_ht_merge({cells})"


def _sc_compress(args, ctx):
    return f"_ht_compress({_compile_node(args[0], ctx)})"


def _sc_packet(args, ctx):
    return f"_ht_packet({_compile_node(args[0], ctx)})"


def _sc_try(args, ctx):
    body = _compile_node(args[0], ctx)
    if len(args) > 1 and args[1][0] == "SEXPR":
        catch_form = args[1][1]
        err_name = _mangle(catch_form[1][1])
        handler_parts = [_compile_node(h, ctx) for h in catch_form[2:]]
        handler = handler_parts[-1] if handler_parts else "None"
        return f"(lambda: ({body},))()[0]" if not handler_parts else \
            f"(lambda: [\n    None\n][-1])()"
    return body


def _sc_throw(args, ctx):
    val = _compile_node(args[0], ctx)
    return f"(_ for _ in ()).throw(Exception({val}))"


def _sc_mod(args, ctx):
    name = _mangle(args[0][1])
    body_lines = [_compile_node(a, ctx) for a in args[1:]]
    return f"{name} = {{}}\n" + "\n".join(body_lines)


def _sc_use(args, ctx):
    mod = _mangle(args[0][1])
    if len(args) == 1:
        return f"globals().update({mod})"
    names = [_mangle(a[1]) for a in args[1:]]
    return "; ".join(f"{n} = {mod}['{n}']" for n in names)


# Intent special forms
def _sc_intent(intent_type):
    def handler(args, ctx):
        content = _compile_node(args[0], ctx) if args else "None"
        return f"_ht_intent({repr(intent_type)}, {content})"
    return handler


_SEXPR_COMPILERS = {
    "def": _sc_def, "let": _sc_let, "fn": _sc_fn, "if": _sc_if,
    "do": _sc_do, "loop": _sc_loop, "match": _sc_match, "|>": _sc_pipe,
    "print": _sc_print, "cell": _sc_cell, "emit": _sc_emit, "recv": _sc_recv,
    "merge": _sc_merge, "compress": _sc_compress, "packet": _sc_packet,
    "mod": _sc_mod, "use": _sc_use,
    "try": _sc_try, "throw": _sc_throw,
    "assert!": _sc_intent("assert"), "ask?": _sc_intent("ask"),
    "request!": _sc_intent("request"), "suggest~": _sc_intent("suggest"),
    "accept+": _sc_intent("accept"), "reject-": _sc_intent("reject"),
    "!": _sc_intent("assert"), "?": _sc_intent("ask"),
    ">": _sc_intent("request"), "~": _sc_intent("suggest"),
    "+": _sc_intent("accept"), "-": _sc_intent("reject"),
    "set-state": lambda args, ctx: f"set_state({', '.join(_compile_node(a, ctx) for a in args)})",
    "get-state": lambda args, ctx: f"get_state({_compile_node(args[0], ctx)})",
}


# ─── Operator mapping ─────────────────────────────────────────────────────

_OP_MAP = {
    "add": "+", "sub": "-", "*": "*", "/": "/", "%": "%",
    "=": "==", "!=": "!=", "<": "<", "gt": ">", "<=": "<=", ">=": ">=",
    "and": "and", "or": "or", "not": "not",
}


def _compile_op(name, args, ctx):
    py_op = _OP_MAP[name]
    compiled = [_compile_node(a, ctx) for a in args]
    if name == "not":
        return f"(not {compiled[0]})"
    if len(compiled) == 1:
        return f"({py_op}{compiled[0]})" if name == "sub" else compiled[0]
    if len(compiled) > 2 and name in ("add", "*"):
        # Variadic: (add 1 2 3) -> (1 + 2 + 3)
        return f"({f' {py_op} '.join(compiled)})"
    return f"({f' {py_op} '.join(compiled)})"


# ─── Helpers ───────────────────────────────────────────────────────────────

def _mangle(name):
    """Convert HiveSpeak identifier to valid Python identifier."""
    # Direct symbol overrides for operators used as values
    _sym_overrides = {
        "*": "_s", "/": "_d", "%": "ht_mod",
        "=": "_eq", "!=": "_neq", "<": "_lt", "<=": "_lte", ">=": "_gte",
    }
    if name in _sym_overrides:
        return _sym_overrides[name]
    replacements = {"-": "_", "?": "_q", "!": "_b", "~": "_t", "+": "_p", "|>": "_pipe"}
    result = name
    for old, new in replacements.items():
        result = result.replace(old, new)
    if result in ("and", "or", "not", "if", "def", "del", "from", "import",
                  "in", "is", "as", "with", "try", "except", "class", "return",
                  "while", "for", "break", "continue", "pass", "raise", "yield",
                  "lambda", "global", "nonlocal", "assert", "else", "elif",
                  "map", "type", "str", "int", "float", "hash",
                  "any", "all", "range", "zip", "len", "add", "sub", "gt"):
        result = f"ht_{result}"
    return result


def _ast_to_pydata(node):
    """Convert AST to Python data for quoted forms."""
    nt = node[0]
    if nt in ("INT", "FLOAT", "STR", "BOOL"):
        return node[1]
    if nt == "NULL":
        return None
    if nt == "SYM":
        return ("SYM", node[1])
    if nt == "KW":
        return node[1]
    if nt == "LIST":
        return [_ast_to_pydata(el) for el in node[1]]
    if nt == "MAP":
        result = {}
        i = 0
        els = node[1]
        while i < len(els) - 1:
            k = _ast_to_pydata(els[i])
            v = _ast_to_pydata(els[i + 1])
            result[k] = v
            i += 2
        return result
    if nt == "SEXPR":
        return [_ast_to_pydata(el) for el in node[1]]
    return str(node)
