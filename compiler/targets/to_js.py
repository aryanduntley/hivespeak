"""HiveSpeak → JavaScript transpiler.

Converts HiveSpeak AST to JavaScript source code.
Pure functional — no global state, no classes.
"""


def compile_to_js(ast_nodes):
    """Compile a list of AST nodes to JavaScript source string."""
    ctx = {"indent": 0}
    lines = [
        "// Generated by HiveSpeak compiler v0.1.0",
        "// Target: JavaScript (ES2020+)",
        "",
        "// HiveSpeak runtime",
        "const _packets = new Map();",
        "",
        "function _htCell(state) {",
        "  const id = Array.from(new Uint8Array(new TextEncoder().encode(JSON.stringify(state))))",
        "    .reduce((h,b) => ((h<<5)-h+b)|0, 0).toString(16).slice(-12);",
        "  return { __type__: 'cell', id, state: {...state}, inbox: [] };",
        "}",
        "",
        "function _htEmit(cell, target, content) {",
        "  if (target && target.__type__ === 'cell') target.inbox.push({from: cell.id, content});",
        "  return content;",
        "}",
        "",
        "function _htRecv(cell) { return cell.inbox.length ? cell.inbox.shift() : null; }",
        "",
        "function _htMerge(cells, keys) {",
        "  const merged = {};",
        "  cells.forEach(c => Object.entries(c.state||{}).forEach(([k,v]) => {",
        "    if (!keys || keys.includes(k)) (merged[k] = merged[k]||[]).push(v);",
        "  }));",
        "  return { __type__: 'collective', shared: merged, cells };",
        "}",
        "",
        "function _htCompress(coll) {",
        "  const compressed = {};",
        "  Object.entries(coll.shared||{}).forEach(([k, values]) => {",
        "    const counts = {};",
        "    values.forEach(v => { const s = JSON.stringify(v); counts[s] = (counts[s]||0)+1; });",
        "    const winner = Object.keys(counts).reduce((a,b) => counts[a]>counts[b]?a:b);",
        "    compressed[k] = JSON.parse(winner);",
        "  });",
        "  const h = Array.from(new TextEncoder().encode(JSON.stringify(compressed)))",
        "    .reduce((h,b) => ((h<<5)-h+b)|0, 0).toString(16).slice(-12);",
        "  const pkt = { __type__: 'packet', hash: h, data: compressed };",
        "  _packets.set(h, pkt);",
        "  return { ok: pkt };",
        "}",
        "",
        "function _htPacket(data) {",
        "  const h = Array.from(new TextEncoder().encode(JSON.stringify(data)))",
        "    .reduce((h,b) => ((h<<5)-h+b)|0, 0).toString(16).slice(-12);",
        "  const pkt = { __type__: 'packet', hash: h, data };",
        "  _packets.set(h, pkt);",
        "  return pkt;",
        "}",
        "",
        "function _htRef(h) { return _packets.get(h) || null; }",
        "",
        "// Standard library",
        "const len = a => a.length;",
        "const hd = a => a[0];",
        "const tl = a => a.slice(1);",
        "const nth = (a, i) => a[i];",
        "const push = (a, v) => [...a, v];",
        "const map = (f, a) => a.map(f);",
        "const flt = (f, a) => a.filter(f);",
        "const red = (f, init, a) => a.reduce(f, init);",
        "const srt = a => [...a].sort((x,y) => x<y?-1:x>y?1:0);",
        "const rev = a => [...a].reverse();",
        "const flat = a => a.flat();",
        "const uniq = a => [...new Set(a)];",
        "const cat = (...a) => typeof a[0]==='string' ? a.join('') : a[0].concat(a[1]);",
        "const slc = (a,s,e) => a.slice(s,e);",
        "const spl = (a,s) => a.split(s);",
        "const upr = a => a.toUpperCase();",
        "const lwr = a => a.toLowerCase();",
        "const fmt = (t,...a) => a.reduce((s,v) => s.replace('{}',String(v)), t);",
        "const get = (m,k) => m[k];",
        "const put = (m,k,v) => ({...m, [k]: v});",
        "const del = (m,k) => { const r={...m}; delete r[k]; return r; };",
        "const keys = m => Object.keys(m);",
        "const vals = m => Object.values(m);",
        "const has = (m,k) => k in m;",
        "const mrg = (a,b) => ({...a,...b});",
        "",
        "// Operator functions (for passing as values)",
        "const _p = (...a) => a.reduce((x,y) => x+y);",
        "const __ = (...a) => a.length === 1 ? -a[0] : a.reduce((x,y) => x-y);",
        "const _s = (...a) => a.reduce((x,y) => x*y);",
        "const _d = (a,b) => b !== 0 ? a/b : Infinity;",
        "const _eq = (a,b) => a === b;",
        "const _neq = (a,b) => a !== b;",
        "const _lt = (a,b) => a < b;",
        "const _gt = (a,b) => a > b;",
        "const _lte = (a,b) => a <= b;",
        "const _gte = (a,b) => a >= b;",
        "",
        "// Generated code",
        "",
    ]
    for node in ast_nodes:
        lines.append(_compile_node(node, ctx) + ";")
    return "\n".join(lines)


# ─── Dispatch table ───────────────────────────────────────────────────────

_COMPILERS = {}


def _compile_node(node, ctx):
    nt = node[0]
    compiler = _COMPILERS.get(nt, lambda n, c: "null")
    return compiler(node, ctx)


def _c_int(n, ctx):    return str(n[1])
def _c_float(n, ctx):  return str(n[1])
def _c_str(n, ctx):    return _js_string(n[1])
def _c_bool(n, ctx):   return "true" if n[1] else "false"
def _c_null(n, ctx):   return "null"
def _c_sym(n, ctx):    return _mangle(n[1])
def _c_kw(n, ctx):     return _js_string(n[1])
def _c_hash(n, ctx):   return f"_htRef({_js_string(n[1])})"


def _c_list(n, ctx):
    return "[" + ", ".join(_compile_node(el, ctx) for el in n[1]) + "]"


def _c_map(n, ctx):
    pairs = n[1]
    items = []
    i = 0
    while i < len(pairs) - 1:
        k = _compile_node(pairs[i], ctx)
        v = _compile_node(pairs[i + 1], ctx)
        items.append(f"[{k}]: {v}")
        i += 2
    return "{" + ", ".join(items) + "}"


def _c_sexpr(n, ctx):
    elements = n[1]
    if not elements:
        return "null"
    head = elements[0]
    args = elements[1:]

    if head[0] == "SYM":
        name = head[1]
        compiler = _SEXPR_COMPILERS.get(name)
        if compiler:
            return compiler(args, ctx)
        if name in _OP_MAP:
            return _compile_op(name, args, ctx)

    fn = _compile_node(head, ctx)
    compiled_args = [_compile_node(a, ctx) for a in args]
    return f"{fn}({', '.join(compiled_args)})"


_COMPILERS.update({
    "INT": _c_int, "FLOAT": _c_float, "STR": _c_str, "BOOL": _c_bool,
    "NULL": _c_null, "SYM": _c_sym, "KW": _c_kw, "HASH": _c_hash,
    "LIST": _c_list, "MAP": _c_map, "SEXPR": _c_sexpr,
    "QUOTE": lambda n, ctx: _js_repr(_ast_to_jsdata(n[1])),
})


# ─── Special form compilers ───────────────────────────────────────────────

def _sc_def(args, ctx):
    if args[0][0] == "SEXPR":
        parts = args[0][1]
        name = _mangle(parts[0][1])
        params = ", ".join(_mangle(p[1]) for p in parts[1:])
        body_parts = [_compile_node(a, ctx) for a in args[1:]]
        if len(body_parts) == 1:
            return f"function {name}({params}) {{ return {body_parts[0]}; }}"
        setup = "; ".join(body_parts[:-1])
        return f"function {name}({params}) {{ {setup}; return {body_parts[-1]}; }}"
    name = _mangle(args[0][1])
    val = _compile_node(args[1], ctx)
    return f"const {name} = {val}"


def _sc_let(args, ctx):
    bindings = args[0][1]
    body = args[1:]
    parts = []
    i = 0
    while i < len(bindings) - 1:
        name = _mangle(bindings[i][1])
        val = _compile_node(bindings[i + 1], ctx)
        parts.append(f"const {name} = {val}")
        i += 2
    body_compiled = [_compile_node(b, ctx) for b in body]
    setup = "; ".join(parts)
    if body_compiled:
        return f"(() => {{ {setup}; return {body_compiled[-1]}; }})()"
    return f"(() => {{ {setup}; }})()"


def _sc_fn(args, ctx):
    params = ", ".join(_mangle(p[1]) for p in args[0][1])
    if len(args) == 2:
        body = _compile_node(args[1], ctx)
        return f"(({params}) => {body})"
    body_parts = [_compile_node(a, ctx) for a in args[1:]]
    setup = "; ".join(body_parts[:-1])
    return f"(({params}) => {{ {setup}; return {body_parts[-1]}; }})"


def _sc_if(args, ctx):
    cond = _compile_node(args[0], ctx)
    then = _compile_node(args[1], ctx)
    els = _compile_node(args[2], ctx) if len(args) > 2 else "null"
    return f"({cond} ? {then} : {els})"


def _sc_do(args, ctx):
    parts = [_compile_node(a, ctx) for a in args]
    if len(parts) == 1:
        return parts[0]
    return f"(() => {{ {'; '.join(parts[:-1])}; return {parts[-1]}; }})()"


def _sc_loop(args, ctx):
    bindings = args[0][1]
    body = args[1:]
    names = []
    vals = []
    i = 0
    while i < len(bindings) - 1:
        names.append(_mangle(bindings[i][1]))
        vals.append(_compile_node(bindings[i + 1], ctx))
        i += 2
    init = "; ".join(f"let {n} = {v}" for n, v in zip(names, vals))
    name_list = ", ".join(names)
    body_compiled = [_compile_node(b, ctx) for b in body]
    body_str = body_compiled[-1] if body_compiled else "null"
    # _Recur sentinel pattern: recur returns a tagged array, loop detects it
    recur_fn = f"const _RECUR = Symbol(); const recur = ({name_list}) => ({{ _t: _RECUR, v: [{name_list}] }})"
    unpack = "; ".join(f"{n} = _r.v[{i}]" for i, n in enumerate(names))
    return (
        f"(() => {{ {init}; {recur_fn}; "
        f"while(true) {{ const _r = {body_str}; "
        f"if (_r && _r._t === _RECUR) {{ {unpack}; }} "
        f"else {{ return _r; }} }} }})()"
    )


def _sc_pipe(args, ctx):
    val = _compile_node(args[0], ctx)
    for step in args[1:]:
        if step[0] == "SEXPR":
            fn = _compile_node(step[1][0], ctx)
            step_args = [_compile_node(a, ctx) for a in step[1][1:]]
            step_args.append(val)
            val = f"{fn}({', '.join(step_args)})"
        else:
            fn = _compile_node(step, ctx)
            val = f"{fn}({val})"
    return val


def _sc_print(args, ctx):
    compiled = [_compile_node(a, ctx) for a in args]
    return f"console.log({', '.join(compiled)})"


def _sc_cell(args, ctx):
    return f"_htCell({_compile_node(args[0], ctx)})"


def _sc_emit(args, ctx):
    compiled = [_compile_node(a, ctx) for a in args]
    return f"_htEmit({', '.join(compiled)})"


def _sc_merge(args, ctx):
    cells = _compile_node(args[0], ctx)
    if len(args) > 2:
        return f"_htMerge({cells}, {_compile_node(args[2], ctx)})"
    return f"_htMerge({cells})"


def _sc_compress(args, ctx):
    return f"_htCompress({_compile_node(args[0], ctx)})"


def _sc_packet(args, ctx):
    return f"_htPacket({_compile_node(args[0], ctx)})"


def _sc_try(args, ctx):
    body = _compile_node(args[0], ctx)
    if len(args) > 1 and args[1][0] == "SEXPR":
        catch_form = args[1][1]
        err_name = _mangle(catch_form[1][1])
        handler = _compile_node(catch_form[2], ctx) if len(catch_form) > 2 else "null"
        return f"(() => {{ try {{ return {body}; }} catch({err_name}) {{ return {handler}; }} }})()"
    return f"(() => {{ try {{ return {body}; }} catch(e) {{ return null; }} }})()"


def _sc_throw(args, ctx):
    return f"(() => {{ throw {_compile_node(args[0], ctx)}; }})()"


_SEXPR_COMPILERS = {
    "def": _sc_def, "let": _sc_let, "fn": _sc_fn, "if": _sc_if,
    "do": _sc_do, "loop": _sc_loop, "|>": _sc_pipe, "print": _sc_print,
    "cell": _sc_cell, "emit": _sc_emit, "merge": _sc_merge,
    "compress": _sc_compress, "packet": _sc_packet,
    "try": _sc_try, "throw": _sc_throw,
}


# ─── Operator mapping ─────────────────────────────────────────────────────

_OP_MAP = {
    "+": "+", "-": "-", "*": "*", "/": "/", "%": "%",
    "=": "===", "!=": "!==", "<": "<", ">": ">", "<=": "<=", ">=": ">=",
    "and": "&&", "or": "||", "not": "!",
}


def _compile_op(name, args, ctx):
    js_op = _OP_MAP[name]
    compiled = [_compile_node(a, ctx) for a in args]
    if name == "not":
        return f"(!{compiled[0]})"
    return f"({' {0} '.format(js_op).join(compiled)})"


# ─── Helpers ───────────────────────────────────────────────────────────────

def _mangle(name):
    # Direct overrides for operators used as values
    _sym_overrides = {
        "+": "_p", "-": "__", "*": "_s", "/": "_d", "%": "ht_mod",
        "=": "_eq", "!=": "_neq", "<": "_lt", ">": "_gt", "<=": "_lte", ">=": "_gte",
    }
    if name in _sym_overrides:
        return _sym_overrides[name]
    replacements = {"-": "_", "?": "_q", "!": "_b", "~": "_t", "+": "_p", "|>": "_pipe"}
    result = name
    for old, new in replacements.items():
        result = result.replace(old, new)
    js_reserved = {"const", "let", "var", "function", "return", "if", "else",
                   "while", "for", "break", "continue", "switch", "case", "default",
                   "new", "delete", "typeof", "void", "this", "class", "import",
                   "export", "from", "try", "catch", "throw", "finally", "in", "of"}
    if result in js_reserved:
        result = f"ht_{result}"
    return result


def _js_string(s):
    return '"' + s.replace("\\", "\\\\").replace('"', '\\"').replace("\n", "\\n") + '"'


def _js_repr(data):
    if data is None:
        return "null"
    if isinstance(data, bool):
        return "true" if data else "false"
    if isinstance(data, (int, float)):
        return str(data)
    if isinstance(data, str):
        return _js_string(data)
    if isinstance(data, list):
        return "[" + ", ".join(_js_repr(x) for x in data) + "]"
    if isinstance(data, dict):
        items = [f"{_js_string(str(k))}: {_js_repr(v)}" for k, v in data.items()]
        return "{" + ", ".join(items) + "}"
    return _js_string(str(data))


def _ast_to_jsdata(node):
    nt = node[0]
    if nt in ("INT", "FLOAT", "STR", "BOOL"):
        return node[1]
    if nt == "NULL":
        return None
    if nt == "SYM":
        return ("SYM", node[1])
    if nt == "KW":
        return node[1]
    if nt == "LIST":
        return [_ast_to_jsdata(el) for el in node[1]]
    if nt == "SEXPR":
        return [_ast_to_jsdata(el) for el in node[1]]
    return str(node)
